import { isPlainObject } from "@tanstack/react-router";
import invariant from "tiny-invariant";
import { startSerializer } from "./serializer.js";
function hydrate(router) {
  var _a, _b, _c;
  invariant(
    (_a = window.__TSR_SSR__) == null ? void 0 : _a.dehydrated,
    "Expected to find a dehydrated data on window.__TSR_SSR__.dehydrated... but we did not. Please file an issue!"
  );
  const { manifest, dehydratedData } = startSerializer.parse(
    window.__TSR_SSR__.dehydrated
  );
  router.ssr = {
    manifest,
    serializer: startSerializer
  };
  router.clientSsr = {
    getStreamedValue: (key) => {
      var _a2;
      if (router.isServer) {
        return void 0;
      }
      const streamedValue = (_a2 = window.__TSR_SSR__) == null ? void 0 : _a2.streamedValues[key];
      if (!streamedValue) {
        return;
      }
      if (!streamedValue.parsed) {
        streamedValue.parsed = router.ssr.serializer.parse(streamedValue.value);
      }
      return streamedValue.parsed;
    }
  };
  const matches = router.matchRoutes(router.state.location);
  const routeChunkPromise = Promise.all(
    matches.map((match) => {
      const route = router.looseRoutesById[match.routeId];
      return router.loadRouteChunk(route);
    })
  );
  matches.forEach((match) => {
    var _a2, _b2, _c2, _d, _e;
    const route = router.looseRoutesById[match.routeId];
    const dehydratedMatch = window.__TSR_SSR__.matches.find(
      (d) => d.id === match.id
    );
    if (dehydratedMatch) {
      Object.assign(match, dehydratedMatch);
      const parentMatch = matches[match.index - 1];
      const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? router.options.context ?? {};
      if (dehydratedMatch.__beforeLoadContext) {
        match.__beforeLoadContext = router.ssr.serializer.parse(
          dehydratedMatch.__beforeLoadContext
        );
        match.context = {
          ...parentContext,
          ...match.__routeContext,
          ...match.__beforeLoadContext
        };
      }
      if (dehydratedMatch.loaderData) {
        match.loaderData = router.ssr.serializer.parse(
          dehydratedMatch.loaderData
        );
      }
      if (dehydratedMatch.error) {
        match.error = router.ssr.serializer.parse(dehydratedMatch.error);
      }
      (_a2 = match.extracted) == null ? void 0 : _a2.forEach((ex) => {
        deepMutableSetByPath(match, ["loaderData", ...ex.path], ex.value);
      });
    } else {
      Object.assign(match, {
        status: "success",
        updatedAt: Date.now()
      });
    }
    const assetContext = {
      matches: router.state.matches,
      match,
      params: match.params,
      loaderData: match.loaderData
    };
    const headFnContent = (_c2 = (_b2 = route.options).head) == null ? void 0 : _c2.call(_b2, assetContext);
    const scripts = (_e = (_d = route.options).scripts) == null ? void 0 : _e.call(_d, assetContext);
    match.meta = headFnContent == null ? void 0 : headFnContent.meta;
    match.links = headFnContent == null ? void 0 : headFnContent.links;
    match.headScripts = headFnContent == null ? void 0 : headFnContent.scripts;
    match.scripts = scripts;
    return match;
  });
  router.__store.setState((s) => {
    return {
      ...s,
      matches
    };
  });
  (_c = (_b = router.options).hydrate) == null ? void 0 : _c.call(_b, dehydratedData);
  return routeChunkPromise;
}
function deepMutableSetByPath(obj, path, value) {
  if (path.length === 1) {
    obj[path[0]] = value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    deepMutableSetByPath(obj[Number(key)], rest, value);
  } else if (isPlainObject(obj)) {
    deepMutableSetByPath(obj[key], rest, value);
  }
}
export {
  hydrate
};
//# sourceMappingURL=ssr-client.js.map
