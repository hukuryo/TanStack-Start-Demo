import { AnyValidator, Constrain, Expand, ResolveValidatorInput, SerializerParse, SerializerStringify, SerializerStringifyBy, Validator } from '@tanstack/react-router';
import { AnyMiddleware, AssignAllClientSendContext, AssignAllServerContext, IntersectAllValidatorInputs, IntersectAllValidatorOutputs } from './createMiddleware.cjs';
export interface JsonResponse<TData> extends Response {
    json: () => Promise<TData>;
}
export type CompiledFetcherFnOptions = {
    method: Method;
    data: unknown;
    headers?: HeadersInit;
    signal?: AbortSignal;
    context?: any;
};
export type Fetcher<TMiddlewares, TValidator, TResponse> = undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator> ? OptionalFetcher<TMiddlewares, TValidator, TResponse> : RequiredFetcher<TMiddlewares, TValidator, TResponse>;
export interface FetcherBase {
    url: string;
    __executeServer: (opts: {
        method: Method;
        data: unknown;
        headers?: HeadersInit;
        context?: any;
        signal: AbortSignal;
    }) => Promise<unknown>;
}
export type FetchResult<TMiddlewares, TResponse, TFullResponse extends boolean> = false extends TFullResponse ? Promise<FetcherData<TResponse>> : Promise<FullFetcherData<TMiddlewares, TResponse>>;
export interface OptionalFetcher<TMiddlewares, TValidator, TResponse> extends FetcherBase {
    <TFullResponse extends boolean>(options?: OptionalFetcherDataOptions<TMiddlewares, TValidator, TFullResponse>): FetchResult<TMiddlewares, TResponse, TFullResponse>;
}
export interface RequiredFetcher<TMiddlewares, TValidator, TResponse> extends FetcherBase {
    <TFullResponse extends boolean>(opts: RequiredFetcherDataOptions<TMiddlewares, TValidator, TFullResponse>): FetchResult<TMiddlewares, TResponse, TFullResponse>;
}
export type FetcherBaseOptions<TFullResponse extends boolean = false> = {
    headers?: HeadersInit;
    type?: ServerFnType;
    signal?: AbortSignal;
    fullResponse?: TFullResponse;
};
export type ServerFnType = 'static' | 'dynamic';
export interface OptionalFetcherDataOptions<TMiddlewares, TValidator, TFullResponse extends boolean> extends FetcherBaseOptions<TFullResponse> {
    data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>;
}
export interface RequiredFetcherDataOptions<TMiddlewares, TValidator, TFullResponse extends boolean> extends FetcherBaseOptions<TFullResponse> {
    data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>;
}
export interface FullFetcherData<TMiddlewares, TResponse> {
    error: unknown;
    result: FetcherData<TResponse>;
    context: AssignAllClientSendContext<TMiddlewares>;
}
export type FetcherData<TResponse> = TResponse extends JsonResponse<any> ? SerializerParse<ReturnType<TResponse['json']>> : SerializerParse<TResponse>;
export type RscStream<T> = {
    __cacheState: T;
};
export type Method = 'GET' | 'POST';
export type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>) => Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>;
export interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {
    method: TMethod;
    data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>;
    context: Expand<AssignAllServerContext<TMiddlewares>>;
    signal: AbortSignal;
}
export type CompiledFetcherFn<TResponse> = {
    (opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>): Promise<TResponse>;
    url: string;
};
type ServerFnBaseOptions<TMethod extends Method = 'GET', TResponse = unknown, TMiddlewares = unknown, TInput = unknown> = {
    method: TMethod;
    validateClient?: boolean;
    middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>;
    validator?: ConstrainValidator<TInput>;
    extractedFn?: CompiledFetcherFn<TResponse>;
    serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>;
    functionId: string;
    type: ServerFnTypeOrTypeFn<TMethod, TMiddlewares, AnyValidator>;
};
export type ValidatorSerializerStringify<TValidator> = Validator<SerializerStringifyBy<ResolveValidatorInput<TValidator>, Date | undefined | FormData>, any>;
export type ConstrainValidator<TValidator> = unknown extends TValidator ? TValidator : Constrain<TValidator, ValidatorSerializerStringify<TValidator>>;
export interface ServerFnMiddleware<TMethod extends Method, TValidator> {
    middleware: <const TNewMiddlewares = undefined>(middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>;
}
export interface ServerFnAfterMiddleware<TMethod extends Method, TMiddlewares, TValidator> extends ServerFnValidator<TMethod, TMiddlewares>, ServerFnTyper<TMethod, TMiddlewares, TValidator>, ServerFnHandler<TMethod, TMiddlewares, TValidator> {
}
export type ValidatorFn<TMethod extends Method, TMiddlewares> = <TValidator>(validator: ConstrainValidator<TValidator>) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>;
export interface ServerFnValidator<TMethod extends Method, TMiddlewares> {
    validator: ValidatorFn<TMethod, TMiddlewares>;
}
export interface ServerFnAfterValidator<TMethod extends Method, TMiddlewares, TValidator> extends ServerFnMiddleware<TMethod, TValidator>, ServerFnTyper<TMethod, TMiddlewares, TValidator>, ServerFnHandler<TMethod, TMiddlewares, TValidator> {
}
export interface ServerFnTyper<TMethod extends Method, TMiddlewares, TValidator> {
    type: (typer: ServerFnTypeOrTypeFn<TMethod, TMiddlewares, TValidator>) => ServerFnAfterTyper<TMethod, TMiddlewares, TValidator>;
}
export type ServerFnTypeOrTypeFn<TMethod extends Method, TMiddlewares, TValidator> = ServerFnType | ((ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>) => ServerFnType);
export interface ServerFnAfterTyper<TMethod extends Method, TMiddlewares, TValidator> extends ServerFnHandler<TMethod, TMiddlewares, TValidator> {
}
export interface ServerFnHandler<TMethod extends Method, TMiddlewares, TValidator> {
    handler: <TNewResponse>(fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>) => Fetcher<TMiddlewares, TValidator, TNewResponse>;
}
export interface ServerFnBuilder<TMethod extends Method = 'GET'> extends ServerFnMiddleware<TMethod, undefined>, ServerFnValidator<TMethod, undefined>, ServerFnTyper<TMethod, undefined, undefined>, ServerFnHandler<TMethod, undefined, undefined> {
    options: ServerFnBaseOptions<TMethod, unknown, undefined, undefined>;
}
type StaticCachedResult = {
    ctx?: {
        result: any;
        context: any;
    };
    error?: any;
};
export type ServerFnStaticCache = {
    getItem: (ctx: MiddlewareResult) => StaticCachedResult | Promise<StaticCachedResult | undefined>;
    setItem: (ctx: MiddlewareResult, response: StaticCachedResult) => Promise<void>;
    fetchItem: (ctx: MiddlewareResult) => StaticCachedResult | Promise<StaticCachedResult | undefined>;
};
export declare function setServerFnStaticCache(cache?: ServerFnStaticCache | (() => ServerFnStaticCache | undefined)): () => void;
export declare function createServerFnStaticCache(serverFnStaticCache: ServerFnStaticCache): ServerFnStaticCache;
export declare function createServerFn<TMethod extends Method, TResponse = unknown, TMiddlewares = undefined, TValidator = undefined>(options?: {
    method?: TMethod;
    type?: ServerFnType;
}, __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>): ServerFnBuilder<TMethod>;
export type MiddlewareOptions = {
    method: Method;
    data: any;
    headers?: HeadersInit;
    signal?: AbortSignal;
    sendContext?: any;
    context?: any;
    type: ServerFnTypeOrTypeFn<any, any, any>;
    functionId: string;
};
export type MiddlewareResult = MiddlewareOptions & {
    result?: unknown;
    error?: unknown;
    type: ServerFnTypeOrTypeFn<any, any, any>;
};
export type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>;
export type MiddlewareFn = (ctx: MiddlewareOptions & {
    next: NextFn;
}) => Promise<MiddlewareResult>;
export {};
