{"version":3,"file":"createServerFn.cjs","sources":["../../src/createServerFn.ts"],"sourcesContent":["import {\n  invariant,\n  isNotFound,\n  isRedirect,\n  warning,\n} from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport { globalMiddleware } from './registerGlobalMiddleware'\nimport { startSerializer } from './serializer'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  ResolveValidatorInput,\n  SerializerParse,\n  SerializerStringify,\n  SerializerStringifyBy,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  AssignAllClientSendContext,\n  AssignAllServerContext,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n  MiddlewareClientFnResult,\n  MiddlewareServerFnResult,\n} from './createMiddleware'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  signal?: AbortSignal\n  context?: any\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator>\n    ? OptionalFetcher<TMiddlewares, TValidator, TResponse>\n    : RequiredFetcher<TMiddlewares, TValidator, TResponse>\n\nexport interface FetcherBase {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n    signal: AbortSignal\n  }) => Promise<unknown>\n}\n\nexport type FetchResult<\n  TMiddlewares,\n  TResponse,\n  TFullResponse extends boolean,\n> = false extends TFullResponse\n  ? Promise<FetcherData<TResponse>>\n  : Promise<FullFetcherData<TMiddlewares, TResponse>>\n\nexport interface OptionalFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  <TFullResponse extends boolean>(\n    options?: OptionalFetcherDataOptions<\n      TMiddlewares,\n      TValidator,\n      TFullResponse\n    >,\n  ): FetchResult<TMiddlewares, TResponse, TFullResponse>\n}\n\nexport interface RequiredFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  <TFullResponse extends boolean>(\n    opts: RequiredFetcherDataOptions<TMiddlewares, TValidator, TFullResponse>,\n  ): FetchResult<TMiddlewares, TResponse, TFullResponse>\n}\n\nexport type FetcherBaseOptions<TFullResponse extends boolean = false> = {\n  headers?: HeadersInit\n  type?: ServerFnType\n  signal?: AbortSignal\n  fullResponse?: TFullResponse\n}\n\nexport type ServerFnType = 'static' | 'dynamic'\n\nexport interface OptionalFetcherDataOptions<\n  TMiddlewares,\n  TValidator,\n  TFullResponse extends boolean,\n> extends FetcherBaseOptions<TFullResponse> {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface RequiredFetcherDataOptions<\n  TMiddlewares,\n  TValidator,\n  TFullResponse extends boolean,\n> extends FetcherBaseOptions<TFullResponse> {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface FullFetcherData<TMiddlewares, TResponse> {\n  error: unknown\n  result: FetcherData<TResponse>\n  context: AssignAllClientSendContext<TMiddlewares>\n}\n\nexport type FetcherData<TResponse> =\n  TResponse extends JsonResponse<any>\n    ? SerializerParse<ReturnType<TResponse['json']>>\n    : SerializerParse<TResponse>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) => Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>\n\nexport interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {\n  method: TMethod\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares>>\n  signal: AbortSignal\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  functionId: string\n  type: ServerFnTypeOrTypeFn<TMethod, TMiddlewares, AnyValidator>\n}\n\nexport type ValidatorSerializerStringify<TValidator> = Validator<\n  SerializerStringifyBy<\n    ResolveValidatorInput<TValidator>,\n    Date | undefined | FormData\n  >,\n  any\n>\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<TValidator, ValidatorSerializerStringify<TValidator>>\n\nexport interface ServerFnMiddleware<TMethod extends Method, TValidator> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>\n}\n\nexport interface ServerFnAfterMiddleware<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnValidator<TMethod, TMiddlewares>,\n    ServerFnTyper<TMethod, TMiddlewares, TValidator>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport type ValidatorFn<TMethod extends Method, TMiddlewares> = <TValidator>(\n  validator: ConstrainValidator<TValidator>,\n) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>\n\nexport interface ServerFnValidator<TMethod extends Method, TMiddlewares> {\n  validator: ValidatorFn<TMethod, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnMiddleware<TMethod, TValidator>,\n    ServerFnTyper<TMethod, TMiddlewares, TValidator>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\n// Typer\nexport interface ServerFnTyper<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> {\n  type: (\n    typer: ServerFnTypeOrTypeFn<TMethod, TMiddlewares, TValidator>,\n  ) => ServerFnAfterTyper<TMethod, TMiddlewares, TValidator>\n}\n\nexport type ServerFnTypeOrTypeFn<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> =\n  | ServerFnType\n  | ((ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>) => ServerFnType)\n\nexport interface ServerFnAfterTyper<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\n// Handler\nexport interface ServerFnHandler<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<TMethod extends Method = 'GET'>\n  extends ServerFnMiddleware<TMethod, undefined>,\n    ServerFnValidator<TMethod, undefined>,\n    ServerFnTyper<TMethod, undefined, undefined>,\n    ServerFnHandler<TMethod, undefined, undefined> {\n  options: ServerFnBaseOptions<TMethod, unknown, undefined, undefined>\n}\n\ntype StaticCachedResult = {\n  ctx?: {\n    result: any\n    context: any\n  }\n  error?: any\n}\n\nexport type ServerFnStaticCache = {\n  getItem: (\n    ctx: MiddlewareResult,\n  ) => StaticCachedResult | Promise<StaticCachedResult | undefined>\n  setItem: (\n    ctx: MiddlewareResult,\n    response: StaticCachedResult,\n  ) => Promise<void>\n  fetchItem: (\n    ctx: MiddlewareResult,\n  ) => StaticCachedResult | Promise<StaticCachedResult | undefined>\n}\n\nlet serverFnStaticCache: ServerFnStaticCache | undefined\n\nexport function setServerFnStaticCache(\n  cache?: ServerFnStaticCache | (() => ServerFnStaticCache | undefined),\n) {\n  const previousCache = serverFnStaticCache\n  serverFnStaticCache = typeof cache === 'function' ? cache() : cache\n\n  return () => {\n    serverFnStaticCache = previousCache\n  }\n}\n\nexport function createServerFnStaticCache(\n  serverFnStaticCache: ServerFnStaticCache,\n) {\n  return serverFnStaticCache\n}\n\nsetServerFnStaticCache(() => {\n  const getStaticCacheUrl = (options: MiddlewareResult, hash: string) => {\n    return `/__tsr/staticServerFnCache/${options.functionId}__${hash}.json`\n  }\n\n  const jsonToFilenameSafeString = (json: any) => {\n    // Custom replacer to sort keys\n    const sortedKeysReplacer = (key: string, value: any) =>\n      value && typeof value === 'object' && !Array.isArray(value)\n        ? Object.keys(value)\n            .sort()\n            .reduce((acc: any, curr: string) => {\n              acc[curr] = value[curr]\n              return acc\n            }, {})\n        : value\n\n    // Convert JSON to string with sorted keys\n    const jsonString = JSON.stringify(json ?? '', sortedKeysReplacer)\n\n    // Replace characters invalid in filenames\n    return jsonString\n      .replace(/[/\\\\?%*:|\"<>]/g, '-') // Replace invalid characters with a dash\n      .replace(/\\s+/g, '_') // Optionally replace whitespace with underscores\n  }\n\n  const staticClientCache =\n    typeof document !== 'undefined' ? new Map<string, any>() : null\n\n  return createServerFnStaticCache({\n    getItem: async (ctx) => {\n      if (typeof document === 'undefined') {\n        const hash = jsonToFilenameSafeString(ctx.data)\n        const url = getStaticCacheUrl(ctx, hash)\n        const publicUrl = process.env.TSS_OUTPUT_PUBLIC_DIR!\n\n        // Use fs instead of fetch to read from filesystem\n        const { promises: fs } = await import('node:fs')\n        const path = await import('node:path')\n        const filePath = path.join(publicUrl, url)\n\n        const [cachedResult, readError] = await fs\n          .readFile(filePath, 'utf-8')\n          .then((c) => [\n            startSerializer.parse(c) as {\n              ctx: unknown\n              error: any\n            },\n            null,\n          ])\n          .catch((e) => [null, e])\n\n        if (readError && readError.code !== 'ENOENT') {\n          throw readError\n        }\n\n        return cachedResult as StaticCachedResult\n      }\n\n      return undefined\n    },\n    setItem: async (ctx, response) => {\n      const { promises: fs } = await import('node:fs')\n      const path = await import('node:path')\n\n      const hash = jsonToFilenameSafeString(ctx.data)\n      const url = getStaticCacheUrl(ctx, hash)\n      const publicUrl = process.env.TSS_OUTPUT_PUBLIC_DIR!\n      const filePath = path.join(publicUrl, url)\n\n      // Ensure the directory exists\n      await fs.mkdir(path.dirname(filePath), { recursive: true })\n\n      // Store the result with fs\n      await fs.writeFile(filePath, startSerializer.stringify(response))\n    },\n    fetchItem: async (ctx) => {\n      const hash = jsonToFilenameSafeString(ctx.data)\n      const url = getStaticCacheUrl(ctx, hash)\n\n      let result: any = staticClientCache?.get(url)\n\n      if (!result) {\n        result = await fetch(url, {\n          method: 'GET',\n        })\n          .then((r) => r.text())\n          .then((d) => startSerializer.parse(d))\n\n        staticClientCache?.set(url, result)\n      }\n\n      return result\n    },\n  })\n})\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method?: TMethod\n    type?: ServerFnType\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBuilder<TMethod> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    type: (type) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { type }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            ...resolvedOptions,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            signal: opts?.signal,\n            context: {},\n          }).then((d) => {\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts_: any, signal: AbortSignal) => {\n            const opts =\n              opts_ instanceof FormData ? extractFormDataContext(opts_) : opts_\n\n            opts.type =\n              typeof resolvedOptions.type === 'function'\n                ? resolvedOptions.type(opts)\n                : resolvedOptions.type\n\n            const ctx = {\n              ...extractedFn,\n              ...opts,\n              signal,\n            }\n\n            const run = () =>\n              executeMiddleware(resolvedMiddleware, 'server', ctx).then(\n                (d) => ({\n                  // Only send the result and sendContext back to the client\n                  result: d.result,\n                  error: d.error,\n                  context: d.sendContext,\n                }),\n              )\n\n            if (ctx.type === 'static') {\n              let response: StaticCachedResult | undefined\n\n              // If we can get the cached item, try to get it\n              if (serverFnStaticCache?.getItem) {\n                // If this throws, it's okay to let it bubble up\n                response = await serverFnStaticCache.getItem(ctx)\n              }\n\n              if (!response) {\n                // If there's no cached item, execute the server function\n                response = await run()\n                  .then((d) => {\n                    return {\n                      ctx: d,\n                      error: null,\n                    }\n                  })\n                  .catch((e) => {\n                    return {\n                      ctx: undefined,\n                      error: e,\n                    }\n                  })\n\n                if (serverFnStaticCache?.setItem) {\n                  await serverFnStaticCache.setItem(ctx, response)\n                }\n              }\n\n              invariant(\n                response,\n                'No response from both server and static cache!',\n              )\n\n              if (response.error) {\n                throw response.error\n              }\n\n              return response.ctx\n            }\n\n            return run()\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = startSerializer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const seen = new Set<AnyMiddleware>()\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  signal?: AbortSignal\n  sendContext?: any\n  context?: any\n  type: ServerFnTypeOrTypeFn<any, any, any>\n  functionId: string\n}\n\nexport type MiddlewareResult = MiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n  type: ServerFnTypeOrTypeFn<any, any, any>\n}\n\nexport type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: MiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<MiddlewareResult>\n\nconst applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: MiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (userCtx: MiddlewareResult | undefined = {} as any) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined ? userCtx.result : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  } as any)\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddleware,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn = (\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        return next(newCtx).catch((error) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        const payload = {\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n          type: typeof ctx.type === 'function' ? ctx.type(ctx) : ctx.type,\n        } as any\n\n        if (\n          ctx.type === 'static' &&\n          process.env.NODE_ENV === 'production' &&\n          typeof document !== 'undefined'\n        ) {\n          invariant(\n            serverFnStaticCache,\n            'serverFnStaticCache.fetchItem is not available!',\n          )\n\n          const result = await serverFnStaticCache.fetchItem(payload)\n\n          if (result) {\n            if (result.error) {\n              throw result.error\n            }\n\n            return next(result.ctx)\n          }\n\n          warning(\n            result,\n            `No static cache item found for ${payload.functionId}__${JSON.stringify(payload.data)}, falling back to server function...`,\n          )\n        }\n\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.(payload)\n\n        return next(res) as unknown as MiddlewareClientFnResult<any, any, any>\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as MiddlewareServerFnResult<any, any, any, any>\n      },\n    },\n  }\n}\n"],"names":["serverFnStaticCache","startSerializer","invariant","mergeHeaders","globalMiddleware","isRedirect","isNotFound","warning"],"mappings":"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"}